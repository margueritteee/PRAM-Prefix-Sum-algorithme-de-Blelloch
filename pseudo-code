
                     PSEUDO-CODE : PARALLEL PREFIX SUM                         
                    (Algorithme de Blelloch - Implémentation)                 


ALGORITHME: parallel_prefix_sum_prof(X)
ENTRÉE: X = tableau de n éléments [x₁, x₂, ..., xₙ]
SORTIE: (somme_prefixe, arbre_somme, arbre_recon)

DÉBUT
    n ← longueur(X)
    
    // Cas de base
    SI n = 0 ALORS
        RETOURNER ([], [], [])
    FIN SI
    
    SI n = 1 ALORS
        RETOURNER ([X[1]], [X], [X])
    FIN SI
    
    // Calcul du nombre de workers (processeurs)
    num_workers ← min(nombre_coeurs_CPU, max(n/2, 1))
    
    
    
     PHASE 1: UP-SWEEP (CONSTRUCTION ARBRE DE SOMME) - PARALLÈLE    
    
    arbre_somme ← [copie(X)]              // Niveau 0 (feuilles)
    niveau_courant ← copie(X)
    
    TANT QUE longueur(niveau_courant) > 1 FAIRE
        
        // Préparer les arguments pour parallélisation
        args ← []
        POUR i ← 0 À longueur(niveau_courant) PAR PAS DE 2 FAIRE
            ajouter (i, niveau_courant) à args
        FIN POUR
        
        // PARALLÉLISATION: Créer num_workers processus
        CRÉER ProcessPoolExecutor AVEC num_workers workers
        
            // Chaque worker exécute calc_tree_pair en parallèle
            POUR CHAQUE Pi, i ∈ {1...num_workers} FAIRE EN PARALLÈLE
                // Pi traite un sous-ensemble de args
                Pour chaque (j, niveau_courant) assigné à Pi:
                    SI j+1 < longueur(niveau_courant) ALORS
                        résultat_Pi ← niveau_courant[j] + niveau_courant[j+1]
                    SINON
                        résultat_Pi ← niveau_courant[j]
                    FIN SI
            FIN POUR EN PARALLÈLE
            
            // Collecter tous les résultats
            niveau_suivant ← [résultats de tous les workers]
        
        FERMER ProcessPoolExecutor
        
        ajouter niveau_suivant à arbre_somme
        niveau_courant ← niveau_suivant
    FIN TANT QUE
    
    // À ce stade: arbre_somme contient tous les niveaux
    // Exemple pour X = [2, 3, -1, 5]:
    //   arbre_somme[0] = [2, 3, -1, 5]    (feuilles)
    //   arbre_somme[1] = [5, 4]           (niveau 1)
    //   arbre_somme[2] = [9]              (racine = somme totale)
    
    
    
      PHASE 2: DOWN-SWEEP (RECONSTRUCTION) - PARALLÈLE                 
    
    
    arbre_recon ← []
    niveau_courant ← [arbre_somme[dernier][1]]    // Racine (somme totale)
    ajouter niveau_courant à arbre_recon
    
    // Descendre niveau par niveau (de haut en bas)
    POUR depth ← longueur(arbre_somme) - 2 JUSQUÀ 0 PAR PAS DE -1 FAIRE
        
        niveau_somme ← arbre_somme[depth]    // Niveau correspondant dans up-tree
        
        // Préparer les arguments pour parallélisation
        args ← []
        POUR i ← 0 À longueur(niveau_courant) - 1 FAIRE
            ajouter (i, niveau_courant, niveau_somme) à args
        FIN POUR
        
        // PARALLÉLISATION: Créer num_workers processus
        CRÉER ProcessPoolExecutor AVEC num_workers workers
        
            // Chaque worker exécute calc_down_sweep_pair en parallèle
            POUR CHAQUE Pi, i ∈ {1...num_workers} FAIRE EN PARALLÈLE
                // Pi traite un sous-ensemble de args
                Pour chaque (j, niveau_courant, niveau_somme) assigné à Pi:
                    pos ← j × 2
                    parent_val ← niveau_courant[j]
                    
                    SI pos+1 < longueur(niveau_somme) ALORS
                        // Formule: gauche = parent - droite
                        gauche ← parent_val - niveau_somme[pos+1]
                        droite ← parent_val
                        résultat_Pi ← [gauche, droite]
                    SINON
                        résultat_Pi ← [parent_val]
                    FIN SI
            FIN POUR EN PARALLÈLE
            
            // Collecter et aplatir tous les résultats
            resultats ← [résultats de tous les workers]
            niveau_suivant ← aplatir(resultats)  // [[g1,d1], [g2,d2]] → [g1,d1,g2,d2]
        
        FERMER ProcessPoolExecutor
        
        ajouter niveau_suivant à arbre_recon
        niveau_courant ← niveau_suivant
    FIN POUR
    
    // Le dernier niveau contient le prefix sum final !
    somme_prefixe ← niveau_suivant
    
    RETOURNER (somme_prefixe, arbre_somme, arbre_recon)
FIN



                         ANALYSE DE COMPLEXITÉ                                


COMPLEXITÉ EN TEMPS:
  • Séquentiel: O(n)
  • Parallèle avec p processeurs: O((n/p) × log n)
  • Profondeur: O(log n) niveaux
  • Chaque niveau: O(n/p) temps avec p workers
  
COMPLEXITÉ EN ESPACE:
  • arbre_somme: n + n/2 + n/4 + ... + 1 ≈ 2n éléments
  • arbre_recon: 1 + 2 + 4 + ... + n ≈ 2n éléments
  • Total: O(n) espace

PARALLÉLISME:
  • UP-SWEEP: Chaque niveau traité en parallèle
  • DOWN-SWEEP: Chaque niveau traité en parallèle
  • Nombre de workers: min(nombre_coeurs, n/2)



                    EXEMPLE DEXÉCUTION PARALLÈLE                            


Entrée: X = [2, 3, -1, 5]
Nombre de workers: 2 (par exemple)

--- UP-SWEEP ---
Niveau 0: [2, 3, -1, 5]
  ↓ (Parallèle avec 2 workers)
  Worker 1 calcule: 2 + 3 = 5
  Worker 2 calcule: -1 + 5 = 4
Niveau 1: [5, 4]
  ↓ (Parallèle avec 1 worker)
  Worker 1 calcule: 5 + 4 = 9
Niveau 2: [9]  ← Racine (somme totale)

--- DOWN-SWEEP ---
Niveau 0: [9]
  ↓ (Parallèle avec 1 worker)
  Worker 1: gauche = 9 - 4 = 5, droite = 9
Niveau 1: [5, 9]
  ↓ (Parallèle avec 2 workers)
  Worker 1: gauche = 5 - 3 = 2, droite = 5
  Worker 2: gauche = 9 - 5 = 4, droite = 9
Niveau 2: [2, 5, 4, 9]  ← PREFIX SUM !

Résultat: [2, 5, 4, 9]
Vérification: 
  [2] = 2
  [2, 3] = 5
  [2, 3, -1] = 4
  [2, 3, -1, 5] = 9  ✓